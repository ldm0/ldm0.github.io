
<!--
Stop checking the code! :-P
These pages are generated by my own blog generation program.
You can get the source code at https://github.com/ldm0/Blogen.
-->
<!DOCTYPE html>
<html>
    <head>
        <title>WTF-8</title>
        <link rel="shortcut icon" type="image/x-icon" href="./assets/favicon.ico">
        <link rel="icon" type="image/x-icon" href="./assets/favicon.ico">
        <link rel="stylesheet" type="text/css" href="./css/common.css">
        <link rel="stylesheet" type="text/css" href="./css/blog.css">
        <script defer src="./js/widget_fun.js"></script>
        <script> 
            MathJax = {
                tex: {
                    inlineMath:[['$', '$']],
                    displayMath:[['$$', '$$']]
                }
            }
        </script>
        <script id="MathJax-script" async src="./js/mathjax/tex-mml-chtml.js"></script>
    </head>
    <body>
        <div id="widget_plate">
            <div class="widget" id="widget_home_page">
                <a href="./index.html">
                    <img src="./assets/homepage.png" alt="homepage">
                </a>
            </div>
            <div class="widget" id="widget_blog_cluster">
                <!--blogs clustered by different tags-->
                <a href="./cluster.html">
                    <img src="./assets/cluster.png" alt="cluster">
                </a>
            </div>
            <div class="widget" id="widget_fun">
                <!--some fun demo-->
                <a href="./fun.html">
                    <img src="./assets/fun.png" alt="fun">
                </a>
                <canvas id="widget_fun_canvas"></canvas>
            </div>
        </div>
        <div id="blog">
            <div id="blog_title">
                WTF-8
            </div>
            <div id="blog_time">
                2021/4/22
            </div>
            <div id="blog_preview">
                介绍一下 Rust 的 OsString 是怎么在阴间的 Windows 平台上实现的。
            </div>
            <div id="blog_content">
                <h3>背景</h3>
<p><code>*nix</code> 系统和 <code>Windows</code> 系统之前的字符串编码不同。<code>*nix</code> 系统的字符串选择大部分都是 <code>UTF-8</code>，<code>Windows</code> 系统 API 则统一使用 <code>UTF-16</code>（有一些细节差异，后面会提到）。与此同时，Rust标准库中有若干API调用了系统函数。为了实现标准库跨平台，Rust语言定义了<code>OsString</code>类型，用于无损的保存系统返回的字符串类型。Rust 标准库 API <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html#method.to_str"><code>to_str</code></a> 提到，如果给定<code>OsString</code>可以被合法的转译为<code>UTF-8</code>，我们就可以从<code>OsString</code>取出一个被标准要求内容是严格 <code>UTF-8</code> 的 <code>&amp;str</code>。</p>
<h3>问题</h3>
<p>之前提到与 Windows 系统 API 交互的字符串编码都是<code>UTF-16</code>。如果<code>OsString</code>里面存储的是<code>UTF-16</code>的话，我们会无法从中拿到一个合法的 <code>UTF-8</code> 的字符串 slice（因为需要返回slice，不能进行临时的转码），那么<code>&amp;str</code>也会创建不出来。而对于内部的存储到底是什么，<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">标准库文档</a>描绘的不那么清楚：</p>
<blockquote>
<p>On Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8.</p>
</blockquote>
<p><code>less-strict variant of UTF-8</code> ...... 这是什么？</p>
<h3>历史</h3>
<p>上面的问题先放一边，<code>Windows</code> API 相关的字符串编码有一些小小的历史（</p>
<ol>
<li>
<p>1991年，<code>Unicode 1.0.0</code>发布（后称<code>UCS-2</code>），<code>UCS-2</code>标准使用16bit作为单个字符大小，非常非常优美。</p>
</li>
<li>
<p>1993年，Windows NT 3.1发布，宣布支持当时<strong>最为先进</strong>的<code>Unicode</code>标准。也是在当时，所有 Win32 API 被分成了<code>xxxA</code>和<code>xxxW</code>两个版本。</p>
</li>
<li>
<p>1996年，Unicode 委员会开始搞事情，推出了<code>Unicode 2.0</code>（后称<code>UTF-16</code>），和<code>UCS-2</code>不一样的地方是出现了代理对（<code>Surrogate Pairs</code>）并且增加了编码范围。<code>0x0000-0xFFFF</code>是<code>UCS-2</code>所有的编码范围，而<code>UTF-16</code>的代理对机制在原本的编码范围内挖了一个洞，这个洞的范围为<code>0xD800-0xDFFF</code>，然后将其中一半<code>0xD800-0xDBFF</code>叫做高位代理（<code>High Surrogate</code>），将另一半<code>0xDC00-0xDFFF</code>叫做低位代理（<code>Low Surrogate</code>）。这样一来，高位代理负责高10bit，低位代理负责低10bit，一个高位代理和一个低位代理组成的代理对可以表示从<code>0x10000-0x10FFFF</code>的<div class="latex">$2^{20}$</div>个字符。因此在添加了代理对之后，<code>0x0000-0xD7FF</code> 和 <code>0xE000-0x10FFFF</code> 是所有的编码范围，这个范围被称作<code>Unicode Scalar Value</code>。合法的<code>UTF-16</code>字符串中，一个高位代理后面一定跟着一个低位代理，所以孤独的代理、两个高位代理、两个低位代理都是不合法的<code>UTF-16</code>。</p>
</li>
</ol>
<ul>
<li>UTF-16 示例（编码两个字符）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">码点（编码值）</th>
<th align="center">UTF-16 串</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">中</td>
<td align="center">U+4E2D</td>
<td align="center">[ 0x4E2D ]</td>
</tr>
<tr>
<td align="center">𐐁</td>
<td align="center">U+10401</td>
<td align="center">[ 0xD801, 0xDC01 ]</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>2000年，Windows 2000 发布，并宣布支持 <code>UTF-16</code>。因为<code>UTF-16</code>编码范围变大了，所以处理<code>UTF-16</code>显然相比<code>UCS-2</code>更复杂。</li>
</ol>
<h3>邪恶</h3>
<p>上面提到了在 Windows 2000 之后，<code>UTF-16</code>得到了支持。<strong>这里的一个华点是</strong>，即使Windows可以正确的处理合法的的<code>UTF-16</code>，但 Win32 API 并没有对<code>UTF-16</code>的合法性进行验证，所以它不拒绝非法的<code>UTF-16</code>串。</p>
<p>我们用一个小例子来看看这件事有多邪恶。总所周知，我们通常可以使用 Win32 API <code>CreateFileW</code> 来在 Windows 上创建一个文件，这个 API 接收一个类型为 <code>LPCWSTR</code>（指向一个 <code>UTF-16</code> 串）的参数（表示文件名）。而我们，Bug 制造机，选择往里面丢一个不合法的<code>UTF-16</code>串:</p>
<pre lang="rust"><code><span style="color:#b48ead;">use </span><span style="color:#4f5b66;">std::ptr;
</span><span style="color:#b48ead;">use </span><span style="color:#4f5b66;">std::env;
</span><span style="color:#b48ead;">use </span><span style="color:#4f5b66;">std::os::windows::ffi::OsStrExt;
</span><span style="color:#b48ead;">use </span><span style="color:#4f5b66;">winapi::um::fileapi::*;
</span><span style="color:#b48ead;">use </span><span style="color:#4f5b66;">winapi::um::winnt::*;
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#4f5b66;">() {
</span><span style="color:#4f5b66;">    </span><span style="color:#b48ead;">let</span><span style="color:#4f5b66;"> current_dir = env::current_dir().</span><span style="color:#96b5b4;">unwrap</span><span style="color:#4f5b66;">();
</span><span style="color:#4f5b66;">    </span><span style="color:#b48ead;">let</span><span style="color:#4f5b66;"> current_dir = current_dir.</span><span style="color:#96b5b4;">as_os_str</span><span style="color:#4f5b66;">();
</span><span style="color:#4f5b66;">    </span><span style="color:#a7adba;">// \ a b c {high surrogate} {high surrogate} d e f
</span><span style="color:#4f5b66;">    </span><span style="color:#b48ead;">let</span><span style="color:#4f5b66;"> evil_filename: Vec&lt;</span><span style="color:#b48ead;">u16</span><span style="color:#4f5b66;">&gt; = vec![</span><span style="color:#d08770;">0x005c</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x0061</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x0062</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x0063</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0xD801</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0xD901</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x0064</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x0065</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x0066</span><span style="color:#4f5b66;">];
</span><span style="color:#4f5b66;">    </span><span style="color:#b48ead;">let</span><span style="color:#4f5b66;"> evil_filepath: Vec&lt;</span><span style="color:#b48ead;">u16</span><span style="color:#4f5b66;">&gt; = current_dir.</span><span style="color:#96b5b4;">encode_wide</span><span style="color:#4f5b66;">().</span><span style="color:#96b5b4;">chain</span><span style="color:#4f5b66;">(evil_filename.</span><span style="color:#96b5b4;">into_iter</span><span style="color:#4f5b66;">()).</span><span style="color:#96b5b4;">chain</span><span style="color:#4f5b66;">(Some(</span><span style="color:#d08770;">0x0000</span><span style="color:#4f5b66;">)).</span><span style="color:#96b5b4;">collect</span><span style="color:#4f5b66;">();
</span><span style="color:#4f5b66;">    println!(&quot;</span><span style="color:#d08770;">{:?}</span><span style="color:#4f5b66;">&quot;, evil_filepath);
</span><span style="color:#4f5b66;">    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#4f5b66;">&quot;, String::from_utf16_lossy(&amp;evil_filepath));
</span><span style="color:#4f5b66;">    </span><span style="color:#b48ead;">let </span><span style="color:#4f5b66;">_ = </span><span style="color:#b48ead;">unsafe </span><span style="color:#4f5b66;">{
</span><span style="color:#4f5b66;">        CreateFileW(
</span><span style="color:#4f5b66;">            evil_filepath.</span><span style="color:#96b5b4;">as_ptr</span><span style="color:#4f5b66;">(),
</span><span style="color:#4f5b66;">            </span><span style="color:#d08770;">GENERIC_WRITE</span><span style="color:#4f5b66;">,
</span><span style="color:#4f5b66;">            </span><span style="color:#d08770;">FILE_SHARE_READ </span><span style="color:#4f5b66;">| </span><span style="color:#d08770;">FILE_SHARE_WRITE </span><span style="color:#4f5b66;">| </span><span style="color:#d08770;">FILE_SHARE_DELETE</span><span style="color:#4f5b66;">,
</span><span style="color:#4f5b66;">            ptr::null_mut(),
</span><span style="color:#4f5b66;">            </span><span style="color:#d08770;">CREATE_ALWAYS</span><span style="color:#4f5b66;">,
</span><span style="color:#4f5b66;">            </span><span style="color:#d08770;">FILE_ATTRIBUTE_NORMAL</span><span style="color:#4f5b66;">,
</span><span style="color:#4f5b66;">            ptr::null_mut(),
</span><span style="color:#4f5b66;">        )
</span><span style="color:#4f5b66;">    };
</span><span style="color:#4f5b66;">}
</span></code></pre>
<p><code>evil_filename</code> 有两个高位代理对，显然这是不合法的<code>UTF-16</code>。我们运行一下：</p>
<p><img src="assets/WTF-8-0.png" alt="image.png" /></p>
<p>当前文件夹下成功创建了一个名称不是合法<code>UTF-16</code>字符串的文件，这个文件看起来就很不对劲:</p>
<p><img src="assets/WTF-8-1.png" alt="image.png" /></p>
<p>我们尝试用VSCode打开它：</p>
<p><img src="assets/WTF-8-2.png" alt="image.png" /></p>
<p>显然 VSCode 没能正确处理这个文件的路径。因此，在调用 Win32 API 的时候，我们甚至可能收到非法的<code>UTF-16</code>（譬如获取文件路径），这非常邪恶。</p>
<h3>答案</h3>
<p>对于 Rust 的标准库成员 <code>OsString</code> ，Windows 上的需求有:</p>
<ol>
<li>
<p>能够无损保存 <code>Windows</code> 系统返回的字符串类型（包括合法的和非法<code>UTF-16</code>）。</p>
</li>
<li>
<p>能够在大部分情况下从中获取到一个<code>UTF-8</code>字符串slice。</p>
</li>
</ol>
<p>还记得之前提出的问题吗？</p>
<p>在上面的需求下，Rust 的 <code>OsString</code> 在 <code>Windows</code> 上被设计成使用 <a href="https://simonsapin.github.io/wtf-8/"><code>WTF-8</code></a> 编码。<code>WTF-8</code> 就是 Rust 文档中提到的那个 <code>less-strict variant of UTF-8</code>。</p>
<p>它的名称起的非常随意，编码的设计却很正经。</p>
<h3>WTF-8</h3>
<p>在介绍<code>WTF-8</code>之前，先介绍一下<code>UTF-8</code>。<code>UTF-8</code>的编码方式如下：</p>
<table>
<thead>
<tr>
<th align="center">码点（编码值）</th>
<th align="center">First byte</th>
<th align="center">Second byte</th>
<th align="center">Third byte</th>
<th align="center">Fourth byte</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">U+0000 to U+007F</td>
<td align="center">0xxxxxxx</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">U+0080 to U+07FF</td>
<td align="center">110xxxxx</td>
<td align="center">10xxxxxx</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">U+0800 to U+FFFF</td>
<td align="center">1110xxxx</td>
<td align="center">10xxxxxx</td>
<td align="center">10xxxxxx</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">U+10000 to U+10FFFF</td>
<td align="center">11110xxx</td>
<td align="center">10xxxxxx</td>
<td align="center">10xxxxxx</td>
<td align="center">10xxxxxx</td>
</tr>
</tbody>
</table>
<p><strong>UTF-8 示例（编码两个字符）</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">码点（编码值）</th>
<th align="center">UTF-16 串</th>
<th align="center">UTF-8 串</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">中</td>
<td align="center">U+4E2D</td>
<td align="center">[ 0x4E2D ]</td>
<td align="center">[ 0xE4 0xB8 0xAD ]</td>
</tr>
<tr>
<td align="center">𐐁</td>
<td align="center">U+10401</td>
<td align="center">[ 0xD801, 0xDC01 ]</td>
<td align="center">[ 0xF0, 0x90, 0x90, 0x81 ]</td>
</tr>
</tbody>
</table>
<p>之前已经介绍过<code>UTF-16</code>编码了。尽管编码方式截然不同，<code>UTF-8</code>和<code>UTF-16</code>共享一个编码范围：<code>Unicode Scalar Value</code>（<code>0x0000-0xD7FF</code> 和 <code>0xE000-0x10FFFF</code>）。</p>
<p><code>WTF-8</code>编码则使用和<code>UTF-8</code>完全相同的编码机制，但是它无视了<code>Unicode Scalar Value</code>中给代理对留下的空缺，支持了<code>0x0000-0x10FFFF</code>范围中所有字符的编码。这样做的意义在于，假设给定的<code>UTF-16</code>含有未成对的代理，我们也能假装这些代理是正常的字符，并用将它用<code>UTF-8</code>的编码机制进行无损转换。</p>
<p>譬如某个未成对代理编码到 <code>WTF-8</code>：</p>
<pre lang="rust"><code><span style="color:#4f5b66;">U+</span><span style="color:#d08770;">D801</span><span style="color:#4f5b66;">(�) =&gt; </span><span style="color:#d08770;">0xD801 </span><span style="color:#4f5b66;">=&gt; [</span><span style="color:#d08770;">0xED</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0xA0</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">0x81</span><span style="color:#4f5b66;">] =&gt; (</span><span style="color:#d08770;">11101101</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">10100000</span><span style="color:#4f5b66;">, </span><span style="color:#d08770;">10000001</span><span style="color:#4f5b66;">)
</span></code></pre>
<p>看起来符合<code>UTF-8</code>的编码格式，但因为 <code>UTF-8</code> 的编码范围不包括 <code>0xD801</code>，所 <code>[0xED, 0xA0, 0x81]</code> 是一个合法的<code>WTF-8</code>字符串，但不是一个合法的 <code>UTF-8</code> 字符串。</p>
<p>这样一来，不论给定的<code>UTF-16</code>串合不合法，我们都能把它编码成<code>WTF-8</code>。</p>
<ul>
<li>如果我们遇到一个合法的<code>UTF-16</code>字符串，由于所有字符都在<code>Unicode Scalar Value</code>的范围中，转码得到的<code>WTF-8</code>串也是一个合法的<code>UTF-8</code>字符串，我们就可以从中拿到一个<code>UTF-8</code>的slice。</li>
<li>如果我们得到一个不合法的<code>UTF-16</code>字符串，由于其中未成对的代理对应的字符编码不在<code>Unicode Scalar Value</code>中，转码得到的是一个不合法的<code>UTF-8</code>串，因此无法从中拿出一个<code>UTF-8</code>的slice。即使这样，我们也能将它无损的用<code>WTF-8</code>编码存储。完美。</li>
</ul>
<p>对应的 Rust 标准库 API <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html#method.to_str"><code>to_str</code></a> 可以从 <code>OsString</code> 中获取 <code>UTF-8</code> slice。它在被调用的时候会进行一遍编码检查，如果发现有未成对的代理字符就会返回<code>None</code>。同时由于 <code>WTF-8</code> 可以无损编码可能非法的 <code>UTF-16</code> 字符串，想要解析出原字符串也完全没有问题。标准库在<a href="https://doc.rust-lang.org/std/os/windows/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a>中给我们提供了<a href="https://doc.rust-lang.org/std/os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide">encode_wide</a>方法。</p>
<h3>简而言之</h3>
<p>说到底 <code>WTF-8</code> 就是用来实现了一个跨平台的字符串兼容层在 Windows 上的兼容性的一个trick，很简单。但我觉得它的设计很有趣，帮我们揭起的黑暗面的一角更有趣。</p>

            </div>
            <div id="blog_tags">
                

                <div class="tag">Rust</div>
                <div class="tag">Unicode</div>
                <div class="tag">Programming</div>
                <div class="tag">Computer Science</div>

            </div>
        </div>
    </body>
</html>
